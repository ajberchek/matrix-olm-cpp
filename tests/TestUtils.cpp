#include <gtest/gtest.h>
#include <json.hpp>
#include <memory>

#include "utils.hpp"

using namespace OlmWrapper::utils;

const char* FortyTwo       = "tests/data/FortyTwo.txt";
const char* ValidKeyUpload = "tests/data/ValidKeyUpload.json";

TEST(TestUtils, GetFileContents) { ASSERT_EQ("42", getFileContents(FortyTwo)); }

TEST(TestUtils, GetRandData) {
    int buff_size = 42;
    ASSERT_FALSE(getRandData(buff_size) == nullptr);
}

TEST(TestUtils, GetMsgInfoInvalid) {
    auto empty = json::parse("{}");
    auto info  = getMsgInfo(empty);
    ASSERT_FALSE(get<0>(info));
}
TEST(TestUtils, GetMsgInfoValid) {
    auto device_keys = json::parse(getFileContents(ValidKeyUpload))["device_keys"];
    auto info        = getMsgInfo(device_keys);
    ASSERT_TRUE(get<0>(info));
    ASSERT_EQ("@alice:example.com", get<1>(info));
    ASSERT_EQ("JLAFKJWSCS", get<2>(info));
    ASSERT_EQ("lEuiRJBit0IG6nUf5pUzWTUEsRVVe/HJkoKuEww9ULI", get<3>(info));
}
TEST(TestUtils, GetMsgUsrID) {
    auto device_keys = json::parse(getFileContents(ValidKeyUpload))["device_keys"];
    string user_id;
    ASSERT_TRUE(getMsgUsrId(device_keys, user_id));
    ASSERT_EQ("@alice:example.com", user_id);
}
TEST(TestUtils, GetMsgDevID) {
    auto device_keys = json::parse(getFileContents(ValidKeyUpload))["device_keys"];
    string dev_id;
    ASSERT_TRUE(getMsgDevId(device_keys, dev_id));
    ASSERT_EQ("JLAFKJWSCS", dev_id);
}
TEST(TestUtils, GetMsgKey) {
    auto device_keys = json::parse(getFileContents(ValidKeyUpload))["device_keys"];
    string key;
    ASSERT_TRUE(getMsgKey(device_keys, key));
    ASSERT_EQ("lEuiRJBit0IG6nUf5pUzWTUEsRVVe/HJkoKuEww9ULI", key);
}

TEST(TestUtils, ToSignable) {
    auto device_keys = json::parse(getFileContents(ValidKeyUpload))["device_keys"];
    string signable;
    toSignable(device_keys, signable);
    ASSERT_EQ(signable.find("signatures"), string::npos);
    ASSERT_EQ(signable.find("unsigned"), string::npos);
    // TODO: consult spec and see what other requirements are present for this to be
    // properly formatted
}

// Verifies the signature generated by utils code is valid
// TODO make this dynamic
TEST(TestUtils, VerifyThisSigned) {
    auto one_time_key = json::parse("{\"key\": \"IxuXdZW1SVN9AsrBjrskj17gKessBnMm+7yvAOwgdG8\",\"signatures\": {\"Zaphod\": {\"ed25519:HeartOfGold\": \"JN23hpj5AeR9RLbQu2d4N59oHMQWWnotDL62eWCcDJhVc7HWHul3fnc920WAFzw20SevxterUzujNuInHYsTAA\"}}}");
    string signing_key = "mwdvZBT+4IIJtcjdIBefvi13hfmPcAtF1HzhyucAt4o";
    ASSERT_TRUE(verify(one_time_key,signing_key));
}
TEST(TestUtils, Verify) {
    auto device_keys = json::parse(getFileContents(ValidKeyUpload))["one_time_keys"]["signed_curve25519:AAAAHg"];
    string key = "lEuiRJBit0IG6nUf5pUzWTUEsRVVe/HJkoKuEww9ULI";
    key = "3C5BFWi2Y8MaVvjM8M22DBmh24PmgR0nPvJOIArzgyI";
    ASSERT_TRUE(verify(device_keys,key));
}

int main(int argc, char** argv) {
    cout << "---RUNNING UTILITY UNIT TESTS---" << endl;
    testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
